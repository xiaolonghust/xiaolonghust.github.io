<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NO WAY OUT | 无往不前</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaolong.li/"/>
  <updated>2018-05-11T15:41:00.094Z</updated>
  <id>http://xiaolong.li/</id>
  
  <author>
    <name>xiaolong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你不知道的Java-之String-StringBuffer-StringBuilder</title>
    <link href="http://xiaolong.li/2018/03/27/You-Do-Not-Know-Java_String-Stringbuffer-StringBuilder/"/>
    <id>http://xiaolong.li/2018/03/27/You-Do-Not-Know-Java_String-Stringbuffer-StringBuilder/</id>
    <published>2018-03-27T08:24:56.000Z</published>
    <updated>2018-05-11T15:41:00.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>StringBuffer，由名字可以看出，是一个String的缓冲区，也就是说一个类似于String的字符串缓冲区，和String不同的是，它可以被修改，而且是线程安全的。StringBuffer在任意时刻都有一个特定的字符串序列，不过这个序列和它的长度可以通过一些函数调用进行修改。</p><a id="more"></a><p>它的结构层次如下图：</p><p>StringBuffer是线程安全的，因此如果有几个线程同时操作StringBuffer，对它来说也只是一个操作序列，所有操作串行发生。</p><p>每一个StringBuffer都有一个容量，如果内容的大小不超过容量，StringBuffer就不会分配更大容量的缓冲区。如果需要更大的容量，StringBuffer会自动增加容量。和StringBuffer类似的有StringBuilder，两者之间的操作相同，不过StringBuilder不是线程安全的。虽然如此，由于StringBuilder没有同步，所以它的速度更快一些。</p><h4 id="StringBuffer的原理"><a href="#StringBuffer的原理" class="headerlink" title="StringBuffer的原理"></a>StringBuffer的原理</h4><p>StringBuffer继承了抽象类AbstractStringBuilder，在AbstractStringBuilder类中，有两个字段分别是char[]类型的value和int类型的count，也就是说，StringBuffer本质上是一个字符数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * The value is used for character storage. </span><br><span class="line"> */  </span><br><span class="line">char[] value;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * The count is the number of characters used. </span><br><span class="line"> */  </span><br><span class="line">int count;</span><br></pre></td></tr></table></figure><p>value用来存储字符，而count表示数组中已有内容的大小，也就是长度。StringBuffer的主要操作有append、insert等，这些操作都是在value上进行的，而不是像String一样每次操作都要new一个String，因此，StringBuffer在效率上要高于String。有了append、insert等操作，value的大小就会改变，那么StringBuffer是如何操作容量的改变的呢？<br>首先StringBuffer有个继承自AbstractStringBuilder类的ensureCapacity的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public synchronized void ensureCapacity(int minimumCapacity) &#123;  </span><br><span class="line">    if (minimumCapacity &gt; value.length) &#123;  </span><br><span class="line">        expandCapacity(minimumCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>StringBuffer对其进行了重写，直接调用父类的expandCapacity方法。这个方法用来保证value的长度大于给定的参数minimumCapacity，在父类的expandCapacity方法中这样操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * This implements the expansion semantics of ensureCapacity with no </span><br><span class="line"> * size check or synchronization. </span><br><span class="line"> */  </span><br><span class="line">void expandCapacity(int minimumCapacity) &#123;  </span><br><span class="line">    int newCapacity = value.length * 2 + 2;  </span><br><span class="line">    if (newCapacity - minimumCapacity &lt; 0)  </span><br><span class="line">        newCapacity = minimumCapacity;  </span><br><span class="line">    if (newCapacity &lt; 0) &#123;  </span><br><span class="line">        if (minimumCapacity &lt; 0) // overflow  </span><br><span class="line">            throw new OutOfMemoryError();  </span><br><span class="line">        newCapacity = Integer.MAX_VALUE;  </span><br><span class="line">    &#125;  </span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，value新的大小是max(value.length*2+2,minimumCapacity)，上面代码中的第二个判断是为了防止newCapacity溢出。<br>同时，StringBuffer还有一个直接设置count大小的函数setLength：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public synchronized void setLength(int newLength) &#123;  </span><br><span class="line">    toStringCache = null;  </span><br><span class="line">    super.setLength(newLength);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数直接调用父类的函数，父类函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void setLength(int newLength) &#123;  </span><br><span class="line">    if (newLength &lt; 0)  </span><br><span class="line">        throw new StringIndexOutOfBoundsException(newLength);  </span><br><span class="line">    ensureCapacityInternal(newLength);  </span><br><span class="line">  </span><br><span class="line">    if (count &lt; newLength) &#123;  </span><br><span class="line">        Arrays.fill(value, count, newLength, &apos;\0&apos;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    count = newLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，如果newLength大于count，那么就会在后面添加’\0’补充。如果小于count，就直接使count=newLength。<br>StringBuffer中的每一个append和insert函数都会调用父类的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public synchronized StringBuffer append(Object obj) &#123;  </span><br><span class="line">    toStringCache = null;  </span><br><span class="line">    super.append(String.valueOf(obj));  </span><br><span class="line">    return this;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@Override  </span><br><span class="line">public synchronized StringBuffer insert(int index, char[] str, int offset,  </span><br><span class="line">                                        int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    toStringCache = null;  </span><br><span class="line">    super.insert(index, str, offset, len);  </span><br><span class="line">    return this;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在父类中，这些函数都会首先保证value的大小够存储要添加的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;  </span><br><span class="line">    if (str == null)  </span><br><span class="line">        return appendNull();  </span><br><span class="line">    int len = str.length();  </span><br><span class="line">    ensureCapacityInternal(count + len);  </span><br><span class="line">    str.getChars(0, len, value, count);  </span><br><span class="line">    count += len;  </span><br><span class="line">    return this;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public AbstractStringBuilder insert(int index, char[] str, int offset,  </span><br><span class="line">                                    int len)  </span><br><span class="line">&#123;  </span><br><span class="line">    if ((index &lt; 0) || (index &gt; length()))  </span><br><span class="line">        throw new StringIndexOutOfBoundsException(index);  </span><br><span class="line">    if ((offset &lt; 0) || (len &lt; 0) || (offset &gt; str.length - len))  </span><br><span class="line">        throw new StringIndexOutOfBoundsException(  </span><br><span class="line">            &quot;offset &quot; + offset + &quot;, len &quot; + len + &quot;, str.length &quot;  </span><br><span class="line">            + str.length);  </span><br><span class="line">    ensureCapacityInternal(count + len);  </span><br><span class="line">    System.arraycopy(value, index, value, index + len, count - index);  </span><br><span class="line">    System.arraycopy(str, offset, value, index, len);  </span><br><span class="line">    count += len;  </span><br><span class="line">    return this;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类中通过ensureCapacityInternal的函数保证大小，函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;  </span><br><span class="line">    // overflow-conscious code  </span><br><span class="line">    if (minimumCapacity - value.length &gt; 0)  </span><br><span class="line">        expandCapacity(minimumCapacity);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果空间不够，最终也是调用expandCapacity方法。这样就保证了随着操作value的空间够用。<br>还有就是，StringBuffer可以通过toString方法转换为String，它有一个私有的字段toStringCache：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * A cache of the last value returned by toString. Cleared </span><br><span class="line"> * whenever the StringBuffer is modified. </span><br><span class="line"> */  </span><br><span class="line">private transient char[] toStringCache;</span><br></pre></td></tr></table></figure><p>也就是一个缓存，用来保存上一次调用toString的结果，如果value的字符串序列发生改变，就会将它清空。toString代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">public synchronized String toString() &#123;  </span><br><span class="line">    if (toStringCache == null) &#123;  </span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, 0, count);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return new String(toStringCache, true);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先判断toStringCache是否为null，如果是先将value复制到缓存里，然后使用toStringCache new一个String。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>StringBuffer有四个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer() value内容为空，并设置容量为16个字节。</span><br><span class="line">StringBuffer(CharSequece seq)  使用seq初始化，容量在此基础上加16。</span><br><span class="line">StringBuffer(int capacity) 设置特定容量。</span><br><span class="line">StringBuffer(String str)  使用str初始化，容量str大小的基础上加16。</span><br></pre></td></tr></table></figure></p><h5 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h5><p>由于继承了Appendable接口，所以要实现append方法，StringBuffer类对几乎所有的基本类型都重载了append方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">append(boolean b)</span><br><span class="line">append(char c)</span><br><span class="line">append(char[] str)</span><br><span class="line">append(char[] str,int offset,int len)</span><br><span class="line">append(CharSequence s)</span><br><span class="line">append(CharSequence s,int start,int end)</span><br><span class="line">append(double d)</span><br><span class="line">append(float f)</span><br><span class="line">append(int i)</span><br><span class="line">append(long lng)</span><br><span class="line">append(Object obj)</span><br><span class="line">append(String str)</span><br><span class="line">append(StringBuffer sb)</span><br></pre></td></tr></table></figure></p><h5 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h5><p>insert方法可以控制插入的起始位置，也几乎对所有的基本类型都重载了insert方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">insert(int offser,boolean b)</span><br><span class="line">insert(int offset,char c)</span><br><span class="line">insert(int offset,char[] str)</span><br><span class="line">insert(int index,char[] str,int offset,int len)</span><br><span class="line">insert(int dsfOffset,CharSequence s)</span><br><span class="line">insert(int dsfOffset,CharSequence s,int start,int end)</span><br><span class="line">insert(int offset,double d)</span><br><span class="line">insert(int offset,float f)</span><br><span class="line">insert(int offset,int i)</span><br><span class="line">insert(int offset,long l)</span><br><span class="line">insert(int offset,Object obj)</span><br><span class="line">insert(int offset,String str)</span><br></pre></td></tr></table></figure></p><h5 id="其它会改变内容的方法"><a href="#其它会改变内容的方法" class="headerlink" title="其它会改变内容的方法"></a>其它会改变内容的方法</h5><p>上面的那些方法会增加StringBuffer的内容，还有一些方法可以改变StringBuffer的内容：</p><p>StringBuffer delete(int start,int end) 删除从start到end（不包含）之间的内容。<br>StringBuffer deleteCharAt(int index) 删除index位置的字符。<br>StringBuffer replace(int start,int end,String str) 用str中的字符替换value中从start到end位置的子序列。<br>StringBuffer reverse() 反转。<br>void setCharAt(int index,char ch) 使用ch替换位置index处的字符。<br>void setLength(int newLength) 可能会改变内容（添加’\0’）。</p><h5 id="其它常用方法"><a href="#其它常用方法" class="headerlink" title="其它常用方法"></a>其它常用方法</h5><p>下面这些方法不会改变内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/** 返回value的大小即容量。 **/</span><br><span class="line">int capacity() </span><br><span class="line"></span><br><span class="line">/** 返回内容的大小，即count。 **/</span><br><span class="line">int length() </span><br><span class="line"></span><br><span class="line">/** 返回位置index处的字符。 **/</span><br><span class="line">char charAt(int index)</span><br><span class="line"> </span><br><span class="line">/** 确保容量至少是minimumCapacity。 **/</span><br><span class="line">void ensureCapacity(int minimumCapacity) </span><br><span class="line"></span><br><span class="line">/** 返回srcBegin到srcEnd的字符到dst。 **/</span><br><span class="line">void getChars(int srcBegin, int srcEnd,char[] dst, int dstBegin) </span><br><span class="line"></span><br><span class="line">/** 返回str第一次出现的位置。 **/</span><br><span class="line">int indexOf(String str) </span><br><span class="line"></span><br><span class="line">/** 返回从fromIndex开始str第一次出现的位置。 **/</span><br><span class="line">int indexOf(String str, int fromIndex) </span><br><span class="line"></span><br><span class="line">/** 返回str最后出现的位置。 **/</span><br><span class="line">int lastIndexOf(String str) </span><br><span class="line"></span><br><span class="line">/** 返回从fromIndex开始最后一次出现str的位置。 **/</span><br><span class="line">int lastIndexOf(String str, int fromIndex) </span><br><span class="line"></span><br><span class="line">/** 返回字符子序列。 **/</span><br><span class="line">CharSequence subSequence(int start, int end) </span><br><span class="line"></span><br><span class="line">/** 返回子串。 **/</span><br><span class="line">String substring(int start) </span><br><span class="line"></span><br><span class="line">/** 返回子串。 **/</span><br><span class="line">String substring(int start, int end) </span><br><span class="line"></span><br><span class="line">/** 返回value形成的字符串。 **/</span><br><span class="line">String toString() </span><br><span class="line"></span><br><span class="line">/** 缩小value的容量到真实内容大小。 **/</span><br><span class="line">void trimToSize()</span><br></pre></td></tr></table></figure></p><h4 id="与String和StringBuilder的区别"><a href="#与String和StringBuilder的区别" class="headerlink" title="与String和StringBuilder的区别"></a>与String和StringBuilder的区别</h4><p>三者都是处理字符串常用的类，不同在于：</p><p>速度上：String &lt; StringBuffer &lt; StringBuilder。</p><p>安全上：StringBuffer线程安全，StringBuilder线程不安全。</p><p>原因在于，String的每次改变都会涉及到字符数组的复制，而StringBuffer和StringBuilder直接在字符数组上改变。同时，StringBuffer是线程安全的，而StringBuilder线程不安全，没有StringBuffer的同步，所以StringBuilder快于StringBuffer。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果对字符串的改变少，使用String。</p><p>如果对字符串修改的较多，需要线程安全就用StringBuffer，不需要就使用StringBuilder。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;StringBuffer，由名字可以看出，是一个String的缓冲区，也就是说一个类似于String的字符串缓冲区，和String不同的是，它可以被修改，而且是线程安全的。StringBuffer在任意时刻都有一个特定的字符串序列，不过这个序列和它的长度可以通过一些函数调用进行修改。&lt;/p&gt;
    
    </summary>
    
      <category term="Java源码" scheme="http://xiaolong.li/categories/Java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://xiaolong.li/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的Java - 之Integer类</title>
    <link href="http://xiaolong.li/2018/03/26/You-Do-Not-Know-Java_Integer/"/>
    <id>http://xiaolong.li/2018/03/26/You-Do-Not-Know-Java_Integer/</id>
    <published>2018-03-26T15:48:09.000Z</published>
    <updated>2018-05-11T15:41:00.094Z</updated>
    
    <content type="html"><![CDATA[<p>Java用了这么久，今天突然发现一个很有意思的事：</p><blockquote><p>为什么在Java中1000 == 1000为false，而100 == 100为true?</p></blockquote><p>这是一个挺有意思的讨论话题。<br>如果你运行下面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 1000, b = 1000;</span><br><span class="line">Integer c = 100, d = 100;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure><p>你会得到：<br>false<br>true</p><a id="more"></a><p>基本知识：我们知道，如果两个引用指向同一个对象，用 == 表示它们是相等的。如果两个引用指向不同的对象，用 == 表示它们是不相等的，即使它们的内容相同。</p><p>因此，后面一条语句也应该是false 。</p><p>这就是它有趣的地方了。如果你看去看Integer.Java类，你会发现有一个内部私有类，IntegerCache.java，它缓存了从-128到127之间的所有的整数对象。</p><p>所以事情就成了，所有的小整数在内部缓存，然后当我们声明类似——<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer c = 100;</span><br><span class="line">``` </span><br><span class="line">的时候，它实际上在内部做的是：</span><br></pre></td></tr></table></figure></p><p>Integer i = Integer.valueOf(100);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在，如果我们去看valueOf()方法，我们可以看到：</span><br></pre></td></tr></table></figure></p><p>public static Integer valueOf(int i) {<br>    if (i &gt;= IntegerCache.low &amp;&amp; i<br>    return IntegerCache.cache[i + (-IntegerCache.low)];<br>    return new Integer(i);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果值的范围在-128到127之间，它就从高速缓存返回实例。</span><br><span class="line"></span><br><span class="line">所以…</span><br></pre></td></tr></table></figure></p><p>Integer c = 100, d = 100;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指向了同一个对象。</span><br><span class="line"></span><br><span class="line">这就是为什么我们写：</span><br></pre></td></tr></table></figure></p><p>System.out.println(c == d);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们可以得到true。</span><br><span class="line"></span><br><span class="line">&gt; 现在你可能会问，为什么这里需要缓存？</span><br><span class="line"></span><br><span class="line">合乎逻辑的理由是，在此范围内的“小”整数使用率比大整数要高，因此，使用相同的底层对象是有价值的，可以减少潜在的内存占用。然而，通过反射API你会误用此功能。</span><br><span class="line"></span><br><span class="line">运行下面的代码，享受它的魅力吧</span><br></pre></td></tr></table></figure></p><p>public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {<br>    Class cache = Integer.class.getDeclaredClasses()[0];<br>    Field myCache = cache.getDeclaredField(“cache”);<br>    myCache.setAccessible(true);<br>    Integer[] newCache = (Integer[]) myCache.get(cache);<br>    newCache[132] = newCache[133];<br>    int a = 2;<br>    int b = a + a;<br>    System.out.printf(“%d + %d = %d”, a, a, b);<br>}<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java用了这么久，今天突然发现一个很有意思的事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么在Java中1000 == 1000为false，而100 == 100为true?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个挺有意思的讨论话题。&lt;br&gt;如果你运行下面的代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer a = 1000, b = 1000;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Integer c = 100, d = 100;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(a == b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(c == d);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你会得到：&lt;br&gt;false&lt;br&gt;true&lt;/p&gt;
    
    </summary>
    
      <category term="Java源码" scheme="http://xiaolong.li/categories/Java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://xiaolong.li/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>InfluxDB数据库管理</title>
    <link href="http://xiaolong.li/2017/06/17/TSDB-INFLUXDB-DBManagement/"/>
    <id>http://xiaolong.li/2017/06/17/TSDB-INFLUXDB-DBManagement/</id>
    <published>2017-06-17T03:43:43.000Z</published>
    <updated>2018-05-11T15:41:00.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于InfluxDB 1.2版本</p></blockquote><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &lt;database_name&gt; [WITH [DURATION &lt;duration&gt;] [REPLICATION &lt;n&gt;] [SHARD DURATION &lt;duration&gt;] [NAME &lt;retention-policy-name&gt;]]</span><br></pre></td></tr></table></figure><h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>和其他数据库一样，使用CREATE DATABASE去创建一个数据库。<br>database_name是数据库名称。<br>创建数据库时可以为该数据库创建数据保留策略，WITH, DURATION, REPLICATION, SHARD DURATION, 和 NAME是用来创建新的策略，如果没有指定创建数据保留策略，则会使用默认策略，InfluxDB默认会为每一个数据库创建一个名为autogen的数据保留策略。</p><a id="more"></a><h4 id="Example-1：创建一个数据库"><a href="#Example-1：创建一个数据库" class="headerlink" title="Example 1：创建一个数据库"></a>Example 1：创建一个数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &quot;NOAA_water_database&quot;</span><br></pre></td></tr></table></figure><p>这条语句会创建一个名为NOAA_water_database的数据库，并使用默认的数据保留策略</p><h4 id="Example-2：创建一个指定数据保留策略的数据库"><a href="#Example-2：创建一个指定数据保留策略的数据库" class="headerlink" title="Example 2：创建一个指定数据保留策略的数据库"></a>Example 2：创建一个指定数据保留策略的数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &quot;NOAA_water_database&quot; WITH DURATION 3d REPLICATION 1 SHARD DURATION 1h NAME &quot;liquid&quot;</span><br></pre></td></tr></table></figure><p>这条语句会创建一个名为NOAA_water_database的数据库，并为其指定一个[过期时间为3天，副本集数为1，SHARDGROUP时间为1小时，名为liquid]的数据保留策略。</p><blockquote><p>当成功执行一个创建数据库语句时，InfluxDB会返回一个空的结果。并且当试图去创建一个已经存在的数据库时，InfluxDB什么都不会做，当然也不会返回错误信息。</p></blockquote><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE &lt;database_name&gt;</span><br></pre></td></tr></table></figure><h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><p>当执行删除数据库的操作成功时，会删除指定数据库中的所有信息，包括 measurements, series, continuous queries, 和 retention policies等。</p><h4 id="Example：删除数据库"><a href="#Example：删除数据库" class="headerlink" title="Example：删除数据库"></a>Example：删除数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE &quot;NOAA_water_database&quot;</span><br></pre></td></tr></table></figure><p>这条语句会删除名为NOAA_water_database的数据库。</p><blockquote><p>当成功执行删除数据库的操作时，InfluxDB会返回一个空的结果。并且当试图去删除一个不存在的数据库时，InfluxDB什么都不会做，当然也不会返回错误信息。</p></blockquote><h3 id="通过DROP-SERIES删除数据"><a href="#通过DROP-SERIES删除数据" class="headerlink" title="通过DROP SERIES删除数据"></a>通过DROP SERIES删除数据</h3><blockquote><p>通过DROP SERIES可以删除一个数据库来自同一个Series的所有Point，并从索引中删除Series。但是它不支持在where从句中使用时间区间[time intervals]。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;=&apos;&lt;tag_value&gt;&apos;</span><br></pre></td></tr></table></figure><h4 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明"></a>语法说明</h4><p>当这条语句执行成功时，会删除所有符合条件的Point</p><h4 id="Example-1：删除一个表中所有Series"><a href="#Example-1：删除一个表中所有Series" class="headerlink" title="Example 1：删除一个表中所有Series"></a>Example 1：删除一个表中所有Series</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SERIES FROM &quot;h2o_feet&quot;</span><br></pre></td></tr></table></figure><p>这条语句执行成功时，会删除h2o_feet中所有序列</p><h4 id="Example-2：通过指定tag删除一个表中的Series"><a href="#Example-2：通过指定tag删除一个表中的Series" class="headerlink" title="Example 2：通过指定tag删除一个表中的Series"></a>Example 2：通过指定tag删除一个表中的Series</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SERIES FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = &apos;santa_monica&apos;</span><br></pre></td></tr></table></figure><p>这条语句执行成功时，会删除h2o_feet中location为santa_monica的所有序列</p><h4 id="Example-3：删除数据库中所有Measurement表中指定tag的所Series"><a href="#Example-3：删除数据库中所有Measurement表中指定tag的所Series" class="headerlink" title="Example 3：删除数据库中所有Measurement表中指定tag的所Series"></a>Example 3：删除数据库中所有Measurement表中指定tag的所Series</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SERIES WHERE &quot;location&quot; = &apos;santa_monica&apos;</span><br></pre></td></tr></table></figure><p>这条语句执行成功时，会删除库中包含所有表中location为santa_monica的所有序列</p><blockquote><p>成功执行DROP SERIES语句返回一个空的结果</p></blockquote><h3 id="通过DELETE-SERIES删除数据"><a href="#通过DELETE-SERIES删除数据" class="headerlink" title="通过DELETE SERIES删除数据"></a>通过DELETE SERIES删除数据</h3><blockquote><p>通过DELETE可以删除一个数据库来自同一个Series的所有Point，与DROP SERIES不同，它不能从索引中删除Series。但是它支持在where从句中使用时间区间[time intervals]。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;measurement_name&gt; WHERE [&lt;tag_key&gt;=&apos;&lt;tag_value&gt;&apos;] | [&lt;time interval&gt;]</span><br></pre></td></tr></table></figure><h4 id="语法说明-2"><a href="#语法说明-2" class="headerlink" title="语法说明"></a>语法说明</h4><p>当这条语句执行成功时，会删除所有符合条件的Point，它支持在WHERE从句中使用时间区间[time intervals]</p><h4 id="Example-1：删除表中所有数据"><a href="#Example-1：删除表中所有数据" class="headerlink" title="Example 1：删除表中所有数据"></a>Example 1：删除表中所有数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &quot;h2o_feet&quot;</span><br></pre></td></tr></table></figure><p>这条语句执行成功后，会清空表h2o_feet中所有数据，并且删除表h2o_feet</p><h4 id="Example-2：通过指定tag值删除数据"><a href="#Example-2：通过指定tag值删除数据" class="headerlink" title="Example 2：通过指定tag值删除数据"></a>Example 2：通过指定tag值删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &quot;h2o_quality&quot; WHERE &quot;randtag&quot; = &apos;3&apos;</span><br></pre></td></tr></table></figure><p>这条语句执行成功后，会删除表h2o_quality中randtag为3的所有数据</p><h4 id="Example-3：通过指定时间区间删除数据"><a href="#Example-3：通过指定时间区间删除数据" class="headerlink" title="Example 3：通过指定时间区间删除数据"></a>Example 3：通过指定时间区间删除数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE WHERE time &lt; &apos;2016-01-01&apos;</span><br></pre></td></tr></table></figure><p>这条语句执行成功后，会删除数据库中在2016-01-01之前的所有数据</p><blockquote><p>DELETE语句执行成功后会返回一个空的结果</p></blockquote><h4 id="关于DELETE要注意的几点："><a href="#关于DELETE要注意的几点：" class="headerlink" title="关于DELETE要注意的几点："></a>关于DELETE要注意的几点：</h4><ol><li>当指定Measurement时，在WHERE从句中使用tag进行操作时，可以使用正则表达式</li><li>DELETE语句在WHERE从句中不支持使用Field字段</li><li></li></ol><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><blockquote><p>通过DROP MEASUREMENT可以从指定的Measurement表中删除所有数据以及Series，并且从索引中删除measuerment</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP MEASUREMENT &lt;measurement_name&gt;</span><br></pre></td></tr></table></figure><h4 id="语法说明-3"><a href="#语法说明-3" class="headerlink" title="语法说明"></a>语法说明</h4><p>通过制定Measurement名称删除表中所有数据</p><h4 id="Example：删除指定表"><a href="#Example：删除指定表" class="headerlink" title="Example：删除指定表"></a>Example：删除指定表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP MEASUREMENT &quot;h2o_feet&quot;</span><br></pre></td></tr></table></figure><p>这条语句执行成功后，可以删除h2o_feet中所有数据，并且从索引中删除</p><blockquote><p>DROP MEASUREMENT语句执行成功后会返回一个空的结果</p></blockquote><h4 id="关于DROP-MEASUREMENT要注意的几点："><a href="#关于DROP-MEASUREMENT要注意的几点：" class="headerlink" title="关于DROP MEASUREMENT要注意的几点："></a>关于DROP MEASUREMENT要注意的几点：</h4><ol><li>DROP MEASUREMENT可以删除指定Measurement中的所有数据以及Series，但是不能删除与之相关的连续查询[continuous queries]</li><li>目前， DROP MEASUREMENT删除指定Measurement时，不能使用正则表达式</li></ol><h3 id="DROP-SHARD"><a href="#DROP-SHARD" class="headerlink" title="DROP SHARD"></a>DROP SHARD</h3><blockquote><p>通过DROP SHARD可以删除一个shard，也可以从元数据中删除这个shard</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SHARD &lt;shard_id_number&gt;</span><br></pre></td></tr></table></figure><h4 id="语法说明-4"><a href="#语法说明-4" class="headerlink" title="语法说明"></a>语法说明</h4><p>通过制定shard_id来删除指定shard</p><h4 id="Example："><a href="#Example：" class="headerlink" title="Example："></a>Example：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP SHARD 1</span><br></pre></td></tr></table></figure><p>这条语句执行成功后，可以删除id为1的shard，并从元数据中删除该shard</p><blockquote><p>DROP SHARD语句执行成功后会返回一个空的结果，即使指定的shard_id不存在，InfluxDB也不会返回一个错误信息</p></blockquote><h2 id="数据保留策略-RETENTION-POLICY"><a href="#数据保留策略-RETENTION-POLICY" class="headerlink" title="数据保留策略[RETENTION POLICY]"></a>数据保留策略[RETENTION POLICY]</h2><p>RETENTION POLICY : 数据保留策略，也叫数据过期策略，是InfluxDB的一个非常重要的概念。数据保留策略是用来定义数据的存放时长，或者是保留某一时间段的数据。每个数据库可以有多个数据保留策略，但只能有一个默认策略。定义数据保留策略是要让InfluxDB知道在什么时候可以丢弃那些很久以前数据，从而达到简单高效的处理数据。</p><p>当新创建一个数据库时，InfluxDB会自动为该数据库创建一个名为aotugen的不限过期时间的策略。你也可以在InfluxDB的配置文件中制定这个默认策略的名称，或者禁用自动创建。</p><h3 id="创建一个策略"><a href="#创建一个策略" class="headerlink" title="创建一个策略"></a>创建一个策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &lt;retention_policy_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt;] [DEFAULT]</span><br></pre></td></tr></table></figure><h4 id="语法说明-5"><a href="#语法说明-5" class="headerlink" title="语法说明"></a>语法说明</h4><p>使用CREATE RETENTION POLICY可以创建一个指定策略名[retention_policy_name]，在一个指定的数据库[database_name]上，指定数据保留时间[duration]，副本集数[n]，SHARDGROUP时间[SHARD DURATION <duration>]，以及是否要作为该数据库的默认策略[DEFAULT]，其中，在创建策略时，SHARD DURATION时间和是否是默认策略可以不指定。</duration></p><h5 id="DURATION"><a href="#DURATION" class="headerlink" title="DURATION"></a>DURATION</h5><p>DURATION定义了在InfluxDB上数据可以保留的时间，是一个时间区域或者是无限期。最小的保留时间是1小时[1h]，最大的保留时间为无限期[0]。该字段单位可以是小时(如2h)，也可以是天(如3d)，当该字段值为0时，表示数据无过期时间，将无限期保留。</p><h5 id="REPLICATION"><a href="#REPLICATION" class="headerlink" title="REPLICATION"></a>REPLICATION</h5><p>REPLICATION定义了在InfluxDB上数据的副本集数，n表示副本集节点的个数。</p><blockquote><p>目前使用InfluxDB都是单实例</p></blockquote><h5 id="SHARD-DURATION"><a href="#SHARD-DURATION" class="headerlink" title="SHARD DURATION"></a>SHARD DURATION</h5><p>SHARD DURATION定义在InfluxDB上一个shardGroup上数据的时间范围，但是不支持无限制时间范围，这是一个可选项，如果不指定，它会根据数据保留时间确定其时间范围，具体对应关键见下表：</p><table><thead><tr><th>Retention Policy’s DURATION</th><th>Shard Group Duration</th></tr></thead><tbody><tr><td>&lt; 2day</td><td>1h</td></tr><tr><td>&gt;= 2 days and &lt;= 6 months</td><td>1 day</td></tr><tr><td>&gt; 6 months</td><td>7 days</td></tr></tbody></table><p>SHARD DURATION最小被允许的值是1h。<br>如果在创建一个策略时，试图将SHARD DURATION的值设为(0s, 1h)区间的值，InfluxDB会自动将其设置为1h。<br>如果在创建一个策略时，试图将SHARD DURATION的值设为0s，InfluxDB会自动按上述默认值设置。</p><h4 id="Example-1：创建策略"><a href="#Example-1：创建策略" class="headerlink" title="Example 1：创建策略"></a>Example 1：创建策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;one_day_only&quot; ON &quot;NOAA_water_database&quot; DURATION 1d REPLICATION 1</span><br></pre></td></tr></table></figure><p>执行这条语句，将会为名为NOAA_water_database的数据库，创建一个名为one_day_only的数据保留策略，该策略数据保留时间为一天，副本集数为1</p><h4 id="Example-2：创建默认策略"><a href="#Example-2：创建默认策略" class="headerlink" title="Example 2：创建默认策略"></a>Example 2：创建默认策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;one_day_only&quot; ON &quot;NOAA_water_database&quot; DURATION 23h60m REPLICATION 1 DEFAULT</span><br></pre></td></tr></table></figure><p>执行这条语句，会创建一个和Example 1一样的策略，但是该策略将作为数据库NOAA_water_database的默认策略</p><blockquote><p>成功创建一个策略会返回一个空的结果。如果试图去创建一个已经存在并且一样的策略，InfluxDB不会返回错误的结果。但是如果试图去创建一个策略名存在，属性不一样的策略时，这时InfluxDB会返回一个错误的结果[Server returned error: retention policy already exists]。</p></blockquote><h3 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER RETENTION POLICY &lt;retention_policy_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; SHARD DURATION &lt;duration&gt; DEFAULT</span><br></pre></td></tr></table></figure><h4 id="语法说明-6"><a href="#语法说明-6" class="headerlink" title="语法说明"></a>语法说明</h4><p>使用ALTER RETENTION POLICY修改一个策略时，必须至少指定修改策略属性[DURATION, REPLICATION, SHARD DURATION, DEFAULT]中的一个。</p><h4 id="Example：修改策略"><a href="#Example：修改策略" class="headerlink" title="Example：修改策略"></a>Example：修改策略</h4><p>首先创建一个策略:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;what_is_time&quot; ON &quot;NOAA_water_database&quot; DURATION 2d REPLICATION 1</span><br></pre></td></tr></table></figure></p><p>这条语句为数据库NOAA_water_database建立一个名为what_is_time，数据保留时间为2天，副本集数为1的策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER RETENTION POLICY &quot;what_is_time&quot; ON &quot;NOAA_water_database&quot; DURATION 7d SHARD DURATION 2h DEFAULT</span><br></pre></td></tr></table></figure></p><p>这条语句将数据库NOAA_water_database上的策略what_is_time的数据保留时间修改为7天，SHARD DURATION修改为2小时，并且作为将数据库NOAA_water_database默认策略。</p><blockquote><p>ALTER RETENTION POLICY语句执行成功后，InfluxDB会返回一个空的结果。如果试图去修改一个不存在的策略，InfluxDB会返回错误信息[Server returned error: retention policy not found: what_is_time_2]。</p></blockquote><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP RETENTION POLICY &lt;retention_policy_name&gt; ON &lt;database_name&gt;</span><br></pre></td></tr></table></figure><h4 id="语法说明-7"><a href="#语法说明-7" class="headerlink" title="语法说明"></a>语法说明</h4><p>DROP RETENTION POLICY可以删除指定数据库上的指定策略</p><h4 id="Example：删除指定策略"><a href="#Example：删除指定策略" class="headerlink" title="Example：删除指定策略"></a>Example：删除指定策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP RETENTION POLICY &quot;what_is_time&quot; ON &quot;NOAA_water_database&quot;</span><br></pre></td></tr></table></figure><p>执行这条语句，会将数据库NOAA_water_database上名为what_is_time的策略删除</p><blockquote><p>DROP RETENTION POLICY语句执行成功后，InfluxDB会返回一个空的结果。如果试图去删除一个不存在的策略，InfluxDB也不会返回错误的信息。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基于InfluxDB 1.2版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据管理&quot;&gt;&lt;a href=&quot;#数据管理&quot; class=&quot;headerlink&quot; title=&quot;数据管理&quot;&gt;&lt;/a&gt;数据管理&lt;/h2&gt;&lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数据库&quot;&gt;&lt;/a&gt;创建数据库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE DATABASE &amp;lt;database_name&amp;gt; [WITH [DURATION &amp;lt;duration&amp;gt;] [REPLICATION &amp;lt;n&amp;gt;] [SHARD DURATION &amp;lt;duration&amp;gt;] [NAME &amp;lt;retention-policy-name&amp;gt;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;语法解析&quot;&gt;&lt;a href=&quot;#语法解析&quot; class=&quot;headerlink&quot; title=&quot;语法解析&quot;&gt;&lt;/a&gt;语法解析&lt;/h4&gt;&lt;p&gt;和其他数据库一样，使用CREATE DATABASE去创建一个数据库。&lt;br&gt;database_name是数据库名称。&lt;br&gt;创建数据库时可以为该数据库创建数据保留策略，WITH, DURATION, REPLICATION, SHARD DURATION, 和 NAME是用来创建新的策略，如果没有指定创建数据保留策略，则会使用默认策略，InfluxDB默认会为每一个数据库创建一个名为autogen的数据保留策略。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiaolong.li/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="时序数据" scheme="http://xiaolong.li/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="InfluxDB" scheme="http://xiaolong.li/tags/InfluxDB/"/>
    
  </entry>
  
  <entry>
    <title>InfluxDB的关键特性</title>
    <link href="http://xiaolong.li/2017/06/09/TSDB-INFLUXDB-Key-Features/"/>
    <id>http://xiaolong.li/2017/06/09/TSDB-INFLUXDB-Key-Features/</id>
    <published>2017-06-09T11:26:23.000Z</published>
    <updated>2018-05-11T15:41:00.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Retention-Policies"><a href="#Retention-Policies" class="headerlink" title="Retention Policies"></a>Retention Policies</h2><p>Retention Policies - 数据保留策略是用来定义数据的存放时长，或者是保留某一时间段的数据。每个数据库可以有多个数据保留策略，但只能有一个默认策略。</p><p>InfluxDB本身是不支持对数据的删除操作，时序数据通常对历史数据的保留时间间隔是有规定的，例如一个线上时序数据业务，可能只需要保留最近1周的数据。为了方便使用，时序数据库必须有数据自动rotate的能力。定义数据保留策略是要让InfluxDB知道在什么时候可以丢弃那些数据，从而达到简单高效的处理数据。</p><a id="more"></a><h3 id="创建策略"><a href="#创建策略" class="headerlink" title="创建策略"></a>创建策略</h3><p>在InfluxDB中，定义一个PILICY的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE RETENTION POLICY &quot;two_hours&quot; ON &quot;food_data&quot; DURATION 2h REPLICATION 1 DEFAULT</span><br></pre></td></tr></table></figure><p>一个策略包括：</p><p>NAME–名称，此示例名称为==two_hours==</p><p>DURATION–持续时间，0代表无限制，此示例为2小时</p><p>shardGroupDuration–shardGroup的存储时间，shardGroup是InfluxDB的一个基本储存结构，应该大于这个时间的数据在查询效率上应该有所降低。</p><p>replicaN–全称是REPLICATION，副本个数</p><p>DEFAULT–是否是默认策略</p><p>上述语句的含义是：</p><blockquote><p>在food_data库上建立一个名为two_hours的策略，该策略的数据保留时间为2h，副本集数为1，该条策略为food_data库的默认策略</p></blockquote><h3 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER RETENTION POLICY &quot;two_hours&quot; ON &quot;food_data&quot; DURATION 4h DEFAULT</span><br></pre></td></tr></table></figure><blockquote><p>示例的作用是将策略”two_hours”的数据保留时间修改为4h</p></blockquote><h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP retention POLICY &quot;two_hours&quot; ON &quot;food_data&quot;</span><br></pre></td></tr></table></figure><blockquote><p>示例是可以将food_data库上的two_hours策略删除</p></blockquote><h2 id="Continuous-Queries"><a href="#Continuous-Queries" class="headerlink" title="Continuous Queries"></a>Continuous Queries</h2><p>Continuous Queries - 连续查询算是InfluxDB的一个大杀器。连续查询是在数据不断进来以后，按指定的查询语句定时地、不断地做聚合，然后放到一个新的系列里面。实际上后面就可以不需要直接在原始数据里面查询，而直接查询这个Continuous Queries生成新的序列。这样查询效率就会快很多，数据只需要在后台不停的算，不停地聚合，从而达到提高查询效率的效果。<br>（注：根据InfluxDB的存储结构，InfluxDB牺牲了读效率而提高了写效率）</p><p>使用连续查询是最优的降低采样率的方式，连续查询和存储策略搭配使用将会大大降低InfluxDB的系统占用量。而且使用连续查询后，数据会存放到指定的数据表中，这样就为以后统计不同精度的数据提供了方便。</p><h3 id="创建一个连续查询"><a href="#创建一个连续查询" class="headerlink" title="创建一个连续查询"></a>创建一个连续查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE CONTINUOUS QUERY &quot;cq_30m&quot; ON &quot;logInfo&quot; BEGIN SELECT mean(utm) INTO &quot;mem_utm_30m&quot; FROM mem GROUP BY time(30m) END</span><br></pre></td></tr></table></figure><blockquote><p>示例在food_data库中新建了一个名为cq_30m 的连续查询，每30m计算一个utm字段的平均值，插入mem_utm_30m表中</p></blockquote><h3 id="显示所有连续查询"><a href="#显示所有连续查询" class="headerlink" title="显示所有连续查询"></a>显示所有连续查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CONTINUOUS QUERIES</span><br></pre></td></tr></table></figure><h3 id="删除连续查询"><a href="#删除连续查询" class="headerlink" title="删除连续查询"></a>删除连续查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP CONTINUOUS QUERY &quot;cq_30m&quot; ON &quot;logInfo&quot;</span><br></pre></td></tr></table></figure><blockquote><p>示例是将logInfo库上名为cq_30的连续删除</p></blockquote><h2 id="自带管理工具"><a href="#自带管理工具" class="headerlink" title="自带管理工具"></a>自带管理工具</h2><p>安装启动完InfluxDB后，可以通过本地8083端口访问web管理页面</p><blockquote><p>官方在1.1.0版本以后，默认关闭了web管理页面</p></blockquote><p>如遇到web打不开的情况，使用如下解决方案</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>打开InfluxDB的配置文件，找到下面几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">### NOTE: This interface is deprecated as of 1.1.0 and will be removed in a future release.</span><br><span class="line">[admin]</span><br><span class="line">  # Determines whether the admin service is enabled.</span><br><span class="line">  # enabled = false</span><br><span class="line"></span><br><span class="line">  # The default bind address used by the admin service.</span><br><span class="line">  # bind-address = &quot;:8083&quot;</span><br><span class="line"></span><br><span class="line">  # Whether the admin service should use HTTPS.</span><br><span class="line">  # https-enabled = false</span><br><span class="line"></span><br><span class="line">  # The SSL certificate used when HTTPS is enabled.</span><br><span class="line">  # https-certificate = &quot;/etc/ssl/influxdb.pem&quot;</span><br><span class="line"></span><br><span class="line">###</span><br></pre></td></tr></table></figure><p>修改enabled = true，bind-address = “:8083”</p><p>并且由配置文件中的</p><blockquote><p>NOTE: This interface is deprecated as of 1.1.0 and will be removed in a future release.</p></blockquote><p>可以看出在1.1.0版本以后默认关闭了web管理页面，在不久的将来这个功能还将被移除。</p><p>本人觉得这个管理页面很人性化，对移除这个功能表示不理解，或许后面会加入新的功能来替代它。就请继续关注吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Retention-Policies&quot;&gt;&lt;a href=&quot;#Retention-Policies&quot; class=&quot;headerlink&quot; title=&quot;Retention Policies&quot;&gt;&lt;/a&gt;Retention Policies&lt;/h2&gt;&lt;p&gt;Retention Policies - 数据保留策略是用来定义数据的存放时长，或者是保留某一时间段的数据。每个数据库可以有多个数据保留策略，但只能有一个默认策略。&lt;/p&gt;
&lt;p&gt;InfluxDB本身是不支持对数据的删除操作，时序数据通常对历史数据的保留时间间隔是有规定的，例如一个线上时序数据业务，可能只需要保留最近1周的数据。为了方便使用，时序数据库必须有数据自动rotate的能力。定义数据保留策略是要让InfluxDB知道在什么时候可以丢弃那些数据，从而达到简单高效的处理数据。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiaolong.li/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="时序数据" scheme="http://xiaolong.li/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="InfluxDB" scheme="http://xiaolong.li/tags/InfluxDB/"/>
    
  </entry>
  
  <entry>
    <title>InfluxDB的基本概念</title>
    <link href="http://xiaolong.li/2017/06/09/TSDB-INFLUXDB-Notion/"/>
    <id>http://xiaolong.li/2017/06/09/TSDB-INFLUXDB-Notion/</id>
    <published>2017-06-09T05:06:47.000Z</published>
    <updated>2018-05-11T15:41:00.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InfluxDB的基本概念"><a href="#InfluxDB的基本概念" class="headerlink" title="InfluxDB的基本概念"></a>InfluxDB的基本概念</h2><p>InfluxDB是Go语言开发的一个开源分布式时序数据库，非常适合存储指标、事件、分析等数据。</p><h3 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE"></a>DATABASE</h3><p>Database - 是数据库最基本的概念，InfluXDB作为时序数据库也不例外。</p><h3 id="MEASUREMENT"><a href="#MEASUREMENT" class="headerlink" title="MEASUREMENT"></a>MEASUREMENT</h3><p>Measurement - 数据表，在InfluxDB中的作用类似传统数据库的table。</p><a id="more"></a><h3 id="TAG-TAGS"><a href="#TAG-TAGS" class="headerlink" title="TAG/TAGS"></a>TAG/TAGS</h3><p>Tag - 标签，在InfluxDB中，Tag是非常重要的概念，在Measurement中存在，并和Measurement一起组成数据库的索引，每个Measurement中可以有多个Tag组成Tags。 索引是以键值对“key-value”形式存在。</p><h3 id="FIELD"><a href="#FIELD" class="headerlink" title="FIELD"></a>FIELD</h3><p>Field - 数据，field主要是用来存放数据部分，也是以键值对“key-value”形式存在。</p><h3 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h3><p>Timestamp - 时间戳，是时序数据库最重要的概念，没有之一。一条数据可以没有Tag，也可以没有Field，但是绝对不能没有Timestamp，可以插入数据时指定，也可以由系统生成。</p><h3 id="POINT"><a href="#POINT" class="headerlink" title="POINT"></a>POINT</h3><p>Point - 点，InfluxDB特有的概念，表示Measurement表中的一行数据，表示每个表里某个时刻的某个条件下的数据，因为体现在图表上就是一个点，于是将其称为Point。一个Point由Timestamp(时间戳)、Tag(标签)、Filed(数据)组成。</p><h3 id="SERIES"><a href="#SERIES" class="headerlink" title="SERIES"></a>SERIES</h3><p>Series - 序列，所有在数据库中的数据，都需要通过图表来表示，Series表示这个表里面的所有的数据可以在图标上画成几条线。<br>（注：线条的个数由tags排列组合计算出来）</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><p><img src="/images/tsdb/measurement.jpg" alt="image"></p><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p><img src="/images/tsdb/series.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;InfluxDB的基本概念&quot;&gt;&lt;a href=&quot;#InfluxDB的基本概念&quot; class=&quot;headerlink&quot; title=&quot;InfluxDB的基本概念&quot;&gt;&lt;/a&gt;InfluxDB的基本概念&lt;/h2&gt;&lt;p&gt;InfluxDB是Go语言开发的一个开源分布式时序数据库，非常适合存储指标、事件、分析等数据。&lt;/p&gt;
&lt;h3 id=&quot;DATABASE&quot;&gt;&lt;a href=&quot;#DATABASE&quot; class=&quot;headerlink&quot; title=&quot;DATABASE&quot;&gt;&lt;/a&gt;DATABASE&lt;/h3&gt;&lt;p&gt;Database - 是数据库最基本的概念，InfluXDB作为时序数据库也不例外。&lt;/p&gt;
&lt;h3 id=&quot;MEASUREMENT&quot;&gt;&lt;a href=&quot;#MEASUREMENT&quot; class=&quot;headerlink&quot; title=&quot;MEASUREMENT&quot;&gt;&lt;/a&gt;MEASUREMENT&lt;/h3&gt;&lt;p&gt;Measurement - 数据表，在InfluxDB中的作用类似传统数据库的table。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiaolong.li/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="时序数据" scheme="http://xiaolong.li/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="InfluxDB" scheme="http://xiaolong.li/tags/InfluxDB/"/>
    
  </entry>
  
  <entry>
    <title>时序数据库</title>
    <link href="http://xiaolong.li/2017/06/08/TSDB-Introduction/"/>
    <id>http://xiaolong.li/2017/06/08/TSDB-Introduction/</id>
    <published>2017-06-08T12:36:59.000Z</published>
    <updated>2018-05-11T15:41:00.094Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2017年时序数据库忽然火了起来。开年2月Facebook开源了beringei时序数据库；到了4月基于PostgreSQL打造的时序数据库TimeScaleDB也开源了，而早在2016年7月，百度云在其天工物联网平台上发布了国内首个多租户的分布式时序数据库产品TSDB，成为支持其发展制造，交通，能源，智慧城市等产业领域的核心产品，同时也成为百度战略发展产业物联网的标志性事件。时序数据库作为物联网方向一个非常重要的服务，业界的频频发声，正说明各家企业已经迫不及待的拥抱物联网时代的到来。</p></blockquote><a id="more"></a><h2 id="什么是时序数据库"><a href="#什么是时序数据库" class="headerlink" title="什么是时序数据库"></a>什么是时序数据库</h2><p>时序数据是基于时间的一系列的数据。在有时间的坐标中将这些数据点连成线，往过去看可以做成多纬度报表，揭示其趋势性、规律性、异常性；往未来看可以做大数据分析，机器学习，实现预测和预警。</p><p>时序数据库就是存放时序数据的数据库，并且需要支持时序数据的快速写入、持久化、多纬度的聚合查询等基本功能。</p><p>对比传统数据库仅仅记录了数据的当前值，时序数据库则记录了所有的历史数据。同时时序数据的查询也总是会带上时间作为过滤条件。</p><p>时序数据示例<br><img src="/images/tsdb/bsg_weather.png" alt="image"></p><h2 id="时序数据库的基本概念及特性"><a href="#时序数据库的基本概念及特性" class="headerlink" title="时序数据库的基本概念及特性"></a>时序数据库的基本概念及特性</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>metric: 度量，相当于关系型数据库中的table。</p><p>data point: 数据点，相当于关系型数据库中的row。</p><p>timestamp：时间戳，代表数据点产生的时间。</p><p>field: 度量下的不同字段。比如位置这个度量具有经度和纬度两个field。一般情况下存放的是会随着时间戳的变化而变化的数据。</p><p>tag: 标签，或者附加信息。一般存放的是并不随着时间戳变化的属性信息。timestamp加上所有的tags可以认为是table的primary key。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>1.压缩能力</p><p>通常用得上时序数据库的业务，产生的数据量都是非常庞大的，数据压缩可以降低存储成本。</p><p>2.自动rotate</p><p>时序数据通常对历史数据的保留时间间隔是有规定的，例如一个线上时序数据业务，可能只需要保留最近1周的数据。为了方便使用，时序数据库必须有数据自动rotate的能力。</p><p>3.插入性能</p><p>时序数据，插入是一个强需求。对于插入性能要求较高。</p><p>4.高效分析能力</p><p>时序数据，除了单条的查询，更多的是报表分析或者其他的分析类需求。这对时序数据库的统计能力也是一个挑战。</p><p>5.支持分片，水平扩展</p><p>业务对时序数据的查询，往往都会带上对时间区间进行过滤，因此时序数据通常在分区时，一定会有一个时间分区的概念。时序数据库务必能够支持自动扩展分区，减少用户的管理量，不需要人为的干预自动扩展分区。例如1月份月末，自动创建2月份的分区。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>业务监控、水文监控、工厂的设备监控、国家安全相关的数据监控、通讯监控等等。</p><p>比如，企业机器集群、业务、性能指标的监控</p><h3 id="loT"><a href="#loT" class="headerlink" title="loT"></a>loT</h3><p>金融行业指标数据、传感器数据等等。</p><p>比如，计步器，运行轨迹等等</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2017年时序数据库忽然火了起来。开年2月Facebook开源了beringei时序数据库；到了4月基于PostgreSQL打造的时序数据库TimeScaleDB也开源了，而早在2016年7月，百度云在其天工物联网平台上发布了国内首个多租户的分布式时序数据库产品TSDB，成为支持其发展制造，交通，能源，智慧城市等产业领域的核心产品，同时也成为百度战略发展产业物联网的标志性事件。时序数据库作为物联网方向一个非常重要的服务，业界的频频发声，正说明各家企业已经迫不及待的拥抱物联网时代的到来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://xiaolong.li/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="时序数据" scheme="http://xiaolong.li/tags/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE/"/>
    
      <category term="InfluxDB" scheme="http://xiaolong.li/tags/InfluxDB/"/>
    
      <category term="监控" scheme="http://xiaolong.li/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="物联网" scheme="http://xiaolong.li/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
      <category term="loT" scheme="http://xiaolong.li/tags/loT/"/>
    
      <category term="TimeScaleDB" scheme="http://xiaolong.li/tags/TimeScaleDB/"/>
    
      <category term="beringei" scheme="http://xiaolong.li/tags/beringei/"/>
    
  </entry>
  
  <entry>
    <title>关于高考</title>
    <link href="http://xiaolong.li/2017/06/07/gaokao/"/>
    <id>http://xiaolong.li/2017/06/07/gaokao/</id>
    <published>2017-06-07T02:29:47.000Z</published>
    <updated>2018-05-11T15:41:00.094Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="随笔" scheme="http://xiaolong.li/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://xiaolong.li/2017/06/05/Introduction/"/>
    <id>http://xiaolong.li/2017/06/05/Introduction/</id>
    <published>2017-06-05T13:02:49.000Z</published>
    <updated>2018-05-11T15:41:00.093Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="随笔" scheme="http://xiaolong.li/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="导言" scheme="http://xiaolong.li/tags/%E5%AF%BC%E8%A8%80/"/>
    
  </entry>
  
</feed>
